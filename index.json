[{"categories":["游戏"],"content":"笔者最早是 2017 年在微博上看到还在开发中的 “迷雾侦探” 的介绍，然后立刻就被它的世界观所吸引。 那时它的英文名还是 Mr. Mist，现在已经改成叫 Tales of the Neon Sea，十分直白地透露了游戏的背景是充满霓虹灯的赛博朋克世界。 最近通关了这个游戏，流程大约 5 个小时，有点意犹未尽：这就结束了？ 总的来说，这是一个一周目的游戏，没有支线，没有多个结局，玩一趟下来仿佛看了一部电影或一本小说。 从游戏很多细节里可以看出，制作人应该是不满足于线性的剧情。 游戏前期阶段主角在事务所楼下的街道可以自由行动，并且可以与不同的路人对话，有些对话甚至暗示了有支线任务，然而实际上并没有。在剧情推进到重要节点时，会弹出提示问玩家是回家睡觉并结束这一天 / 进入新场景且不能回头，还是再继续逛逛 / 有事情没处理完。 这是提示玩家清理支线任务的常用手法。然而在迷雾侦探里，选择 “继续逛逛” 也不能做什么特别的事情，甚至不能出房间，让人迷惑提供这些选项的意义在哪里。 游戏的收集要素里透露了很多背景设定：机器人进化出了情感，开始有自我意识，人类对机器人十分排斥，甚至发生了战争，称为 “人机大战”。然而，这些设定也就只是躺在收集品介绍和 NPC 的对话里，跟剧情毫无关系。 总之，游戏里充满了没有填上的坑，或者草草收场的痕迹。 抛开赛博朋克的外衣，这个游戏的本质是一个类似于“机械迷城”的点击式的解谜游戏，难度比机械迷城还要容易一些。 看过早期的测评文章和开发者放出的初版设计稿，发现现在的版本里很多小谜题已经做了更改或者简化，想必不少其他玩家对之前的谜题颇有意见。 迷雾侦探的谜题设计有一些亮点：把现场调查、线索收集的元素融入了解谜中，但也只是包装了一下。线索的整理只需要把指定的几个线索找到，点一个按钮，就自动得到结论，玩家不需要做任何分析。这对于侦探游戏来说不是一个好的处理方法。 美术上没有什么可挑剔的，虽然是像素风格，画面细节却也很到位。 像素风简化了建模和动画，加上游戏是 2D 横板场景，只要在背景上叠 sprite 就行了。 其他像光照等方面不需要受到像素风格的限制。例如霓虹灯的泛光、射灯的体积光效果，都是比较柔和的，显示出这仍然是一个高分辨率的游戏。 游戏里有不少彩蛋，玩梗要适度啊。 主角的助理机器人造型是 Wall-E，但名字叫 BB-X 事务所二楼的通缉海贼王的海报 事务所楼下的 7-12 便利店 有一个小女孩 NPC 的头像是灰原哀，她有一个机器人同伴叫 “南柯” 主角用锡纸独角兽测试机器人，致敬了 “银翼杀手” 桥下区入口的 “宇宙牌香烟” 广告牌 … 作为独立游戏，迷雾侦探基本是合格的。 看得出玩家在发售前对它抱有过大的期望，其中也包括笔者。当拿到手里的是一个没有那么出色的成品时，不少人难免有些失望。 往好了看，在国内能达到这个水平的独立游戏也不多，我们仍然在进步，对不对？ ","date":"2021-08-11","objectID":"/mr.mist-game-review/:0:0","tags":null,"title":"[游戏评论] 迷雾侦探","uri":"/mr.mist-game-review/"},{"categories":["游戏"],"content":"偶然发现一个小游戏，叫 Hocus，中文翻译叫“迷惑”或“错觉”。 是一个利用视错觉的解谜类游戏。不禁让人联想到“纪念碑谷”。可谓是一提到视错觉游戏，必绕不过“纪念碑谷”。然而这个游戏更像“无限回廊”（Echochrome）一点。 言归正传，这个游戏的机制是控制红色方块在平台上移动，只能在表面平动，不能翻过棱边，要始终保证方块至少有一个面与平台接触。 目标是要让它到达红色的格子上。 平台看上去是三维模型，但构造上属于局部合理而整体上矛盾的结构。这也正式此类视错觉的精髓所在。抓住这一点设计出来的游戏总让人眼前一亮。 略遗憾的是，Hocus 也就止步于此。游戏共有 100 个关卡，难度总体是递增的，后面几十关难度都差不多，再也没有其他变化。 解谜也没啥好说的，本质上就是一个走迷宫的游戏，用深度优先搜索即可。 如果一次全部通关难免会感到厌倦。大概这只是作者练手的作品吧。 Hocus 还有一个续作 Hocus 2，比起前作更有一点游戏的样子。同样有 100 个左右的关卡，机制更丰富。除了视错觉这个核心要素和到达红色格子的目标不变以外，有些关卡增加了阻碍，比如平台的某些格子在走过一次之后会消失，而不能往回走；有些关卡需要躲避随机游走的敌人；有些需要抓住到处乱跑的小球；还有一些关可以控制平台变化成不同的构造。 两作难度上差不多，甚至续作可能更简单一点。每关花费的时间在 1~5 分钟不等，比如下图就是典型的一关。想必聪明的你早已看出了走法 ^_^ \\begin{tikzpicture}[scale=1]\r\\definecolor{color1}{rgb}{0.9,0.9,0.9}\r\\definecolor{color3}{rgb}{0.75,0.75,0.75}\r\\definecolor{color2}{rgb}{0.6,0.6,0.6}\r\\coordinate[] (A1) at (-4.4,-0.2);\r\\coordinate[] (A2) at (-4.4,0.2);\r\\coordinate[] (A3) at (-4.4,1.8);\r\\coordinate[] (A4) at (-4.4,2.2);\r\\coordinate[] (B1) at (-4.0,2.0);\r\\coordinate[] (C1) at (-3.6,0.2);\r\\coordinate[] (C2) at (-3.6,2.2);\r\\coordinate[] (D1) at (-3.2,0);\r\\coordinate[] (D2) at (-3.2,2);\r\\coordinate[] (E1) at (-2.8,1);\r\\coordinate[] (F1) at (-2.4,1.2);\r\\coordinate[] (F2) at (-2.4,3.2);\r\\coordinate[] (F3) at (-2.4,3.6);\r\\coordinate[] (G1) at (-2,0.6);\r\\coordinate[] (G2) at (-2,1);\r\\coordinate[] (G3) at (-2,2.6);\r\\coordinate[] (G4) at (-2,3);\r\\coordinate[] (G5) at (-2,3.4);\r\\coordinate[] (G6) at (-2,3.8);\r\\coordinate[] (H1) at (-1.6,3.2);\r\\coordinate[] (H2) at (-1.6,3.6);\r\\coordinate[] (I1) at (-0.4,-0.2);\r\\coordinate[] (I2) at (-0.4,0.2);\r\\coordinate[] (I3) at (-0.4,0.6);\r\\coordinate[] (I4) at (-0.4,1.8);\r\\coordinate[] (J1) at (0,-2.4);\r\\coordinate[] (J2) at (0,-2);\r\\coordinate[] (J3) at (0,-1.6);\r\\coordinate[] (J4) at (0,-0.4);\r\\coordinate[] (J5) at (0,1.6);\r\\coordinate[] (J6) at (0,2);\r\\coordinate[] (J7) at (0,2.4);\r\\coordinate[] (K1) at (0.4,-0.2);\r\\coordinate[] (K2) at (0.4,1.8);\r\\coordinate[] (K3) at (0.4,2.2);\r\\coordinate[] (L1) at (1.6,-0.8);\r\\coordinate[] (L2) at (1.6,2.4);\r\\coordinate[] (M1) at (2,-1.4);\r\\coordinate[] (M2) at (2,-1);\r\\coordinate[] (M3) at (2,2.6);\r\\coordinate[] (M4) at (2,3);\r\\coordinate[] (M5) at (2,3.4);\r\\coordinate[] (N1) at (2.4,-1.2);\r\\coordinate[] (N2) at (2.4,-0.8);\r\\coordinate[] (N3) at (2.4,-0.4);\r\\coordinate[] (N4) at (2.4,2.4);\r\\coordinate[] (O1) at (3.6,0.2);\r\\coordinate[] (O2) at (3.6,1.8);\r\\coordinate[] (P1) at (4,0);\r\\coordinate[] (P2) at (4,2);\r\\coordinate[] (Q1) at (4.4,-0.2);\r\\coordinate[] (Q2) at (4.4,2.2);\r\\draw[line width=1pt,fill=color3] (A2)--(J2)--(M2)--(L1)--(J3)--(C1)--(G2)--(I2)--(I3)--(C2)--(G4)--(F2)--(A4)--(F1)--cycle;\r\\draw[line width=1pt,fill=color3] (N3)--(N2)--(P1)--(O1)--cycle;\r\\draw[line width=1pt,fill=color3] (Q2)--(M5)--(J7)--(H1)--(G4)--(J6)--(M4)--(P2)--cycle;\r\\draw[line width=1pt,fill=color2] (K1)--(J4)--(J6)--(M4)--(M3)--(K2)--cycle;\r\\draw[line width=1pt,fill=color2] (P2)--(P1)--(N2)--(N1)--(Q1)--(Q2)--cycle;\r\\draw[line width=1pt,fill=color2] (J2)--(J1)--(M1)--(M2)--cycle;\r\\draw[line width=1pt,fill=color2] (C2)--(D2)--(G3)--(G4)--cycle;\r\\draw[line width=1pt,fill=color2] (C1)--(D1)--(G1)--(G2)--cycle;\r\\draw[line width=1pt,fill=color2] (M3)--(M2)--(N2)--(N4)--cycle;\r\\draw[line width=1pt,fill=color1] (A4)--(A3)--(E1)--(F1)--cycle;\r\\draw[line width=1pt,fill=color1] (A2)--(A1)--(J1)--(J2)--cycle;\r\\draw[line width=1pt,fill=color1] (M3)--(M4)--(P2)--(P1)--(O1)--(O2)--cycle;\r\\draw[line width=1pt,fill=color1] (G4)--(G3)--(I4)--(I2)--(G2)--(G1)--(J4)--(J6)--cycle;\r\\draw[line width=1pt,fill=color1] (L2)--(L1)--(M2)--(M3)--cycle;\r\\draw[line width=1pt,fill=pink] (F3)--(F2)--(G4)--(G5)--cycle;\r\\draw[line width=1pt,fill=pink] (G5)--(G4)--(H1)--(H2)--cycle;\r\\draw[line width=1pt,fill=pink] (F3)--(G5)--(H2)--(G6)--cycle;\r\\draw[line width=1pt,fill=pink] (M1)--(N1)--(N2)--(M2)--cycle;\r\\end{tikzpicture}\r\r\r如果上一个迷宫可能过于简单，这里再给出一个稍复杂一点的。 \\begin{tikzpicture}[scale=1]\r\\definecolor{color1}{rgb}{0.9,0.9,0.9}\r\\definecolor{color3}{rgb}{0.75,0.75,0.75}\r\\definecolor{color2}{rgb}{0.6,0.6,0.6}\r\\coordinate[] (A1) at (-4.4","date":"2021-07-24","objectID":"/hocus-game-review/:0:0","tags":null,"title":"[游戏评论] Hocus","uri":"/hocus-game-review/"},{"categories":null,"content":"未分类的内容.","date":"2021-07-14","objectID":"/misc/","tags":null,"title":"杂项","uri":"/misc/"},{"categories":null,"content":"这里列出了各种转载、存档、图片内容，版权归原作者所有。 ","date":"2021-07-14","objectID":"/misc/:0:0","tags":null,"title":"杂项","uri":"/misc/"},{"categories":null,"content":"一些有用的链接和站点.","date":"2021-07-14","objectID":"/links/","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"这里整理了一些有用的链接和站点. ","date":"2021-07-14","objectID":"/links/:0:0","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"网站 ","date":"2021-07-14","objectID":"/links/:1:0","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"图形学资源合集 Ke-Sen Huang 收集的图形会议(SIGGRAPH / SIGGRAPH Asia / EG / EGSR / I3D)论文: http://kesen.realtimerendering.com/ Self Shadow, 历年 SIGGRAPH Course 资源收集: https://blog.selfshadow.com/ GDC Vault: https://www.gdcvault.com/ Unreal Engine 官方社区精选: https://www.zhihu.com/column/egc-community ","date":"2021-07-14","objectID":"/links/:1:1","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"游戏 / 实时渲染 Realtime Rendering: http://www.realtimerendering.com/blog/ Inigo Quilez, 大名鼎鼎的iq大神, ShaderToy的作者: https://www.iquilezles.org/www/index.htm Jendrik Illner 的图形技术周刊: https://www.jendrikillner.com/ 云风: https://blog.codingnow.com/ Simon Trümpler, TA of RIME, 介绍了大量主流 3A 游戏的抓帧分析 : https://simonschreibt.de/ Alan Wolfe @NVidia/Blizzard: https://blog.demofox.org/ 冯乐乐(@miHoYo): http://candycat1992.github.io/ 毛星云(@Tencent) 的图形学笔记: https://github.com/QianMo/Game-Programmer-Study-Notes Wu Yuwen @Messiah Engine(Netease): https://atyuwen.github.io/ Ma Yidong @Taichi/Unisoft/Netease: http://ma-yidong.com/ Qian Kanglai @Netease: http://qiankanglai.me/ ","date":"2021-07-14","objectID":"/links/:1:2","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"学术 Wenzel Jakob, author of Mistuba: https://rgl.epfl.ch/people/wjakob ","date":"2021-07-14","objectID":"/links/:1:3","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"开源代码 ","date":"2021-07-14","objectID":"/links/:2:0","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"开源游戏引擎 Unreal Engine: https://github.com/EpicGames/UnrealEngine CRYENGINE: https://github.com/CRYTEK/CRYENGINE Godot: https://github.com/godotengine/godot Flax Engine: https://github.com/FlaxEngine/FlaxEngine Stride Game Engine (formerly Xenko): https://github.com/stride3d/stride Lumix Engine: https://github.com/nem0/LumixEngine Open 3D Engine: https://github.com/o3de/o3de ","date":"2021-07-14","objectID":"/links/:2:1","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"渲染 开源实时渲染框架 bgfx: https://github.com/bkaradzic/bgfx The Forge, : https://github.com/ConfettiFX/The-Forge OGRE-next: https://github.com/OGRECave/ogre-next OGRE: https://github.com/OGRECave/ogre Google Filament: https://github.com/google/filament LÖVE - 带 lua 绑定的 2D 渲染框架: https://github.com/love2d/love Amulet - 带 lua 绑定的渲染框架: https://github.com/ianmaclarty/amulet 离线渲染 blender: https://github.com/blender/blender PBRT: https://github.com/mmp/pbrt-v4 mitsuba2: https://github.com/mitsuba-renderer/mitsuba2 Intel embree: https://github.com/embree/embree pov ray: https://github.com/POV-Ray/povray G3D by casual-effects, 支持离线和实时渲染: https://casual-effects.com/g3d/www/index.html tungsten: https://github.com/tunabrain/tungsten Apple Seed: https://github.com/appleseedhq/appleseed ","date":"2021-07-14","objectID":"/links/:2:2","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":null,"content":"其他开源项目 Nintendo Switch 模拟器 Ryujinx - 使用 C# 编写的 NS 模拟器: https://github.com/Ryujinx/Ryujinx yuzu - 使用 C++ 编写的 NS 模拟器: https://github.com/yuzu-emu/yuzu FC/NES 模拟器 bsnes: https://github.com/bsnes-emu/bsnes higan - 多合一模拟器，包括 FC、GB 等: https://github.com/higan-emu/higan 可视化 manim - 3Blue1Brown 使用的动画引擎: https://github.com/ManimCommunity/manim/ 图形界面 Dear ImGui: https://github.com/ocornut/imgui nanogui: https://github.com/mitsuba-renderer/nanogui ","date":"2021-07-14","objectID":"/links/:2:3","tags":null,"title":"链接/网络资源","uri":"/links/"},{"categories":["故事"],"content":"“老实交代，你们这个窝点存在多久了？” 会所包厢内，暧昧的灯光下蹲着十来名男男女女，男的衣着光鲜，女的衣着暴露。这些在朋友圈里扮着绅士名媛的年轻人，在警察的逼问下通通抱着头，只希望在场没有人把他们拍下来发朋友圈。 Cassie躲在角落里深深埋着她的一头卷发。这是她来夜色会所的第7个月。今天刚好是她30岁的生日，“金主”们和她手下的姐妹们带来的奢侈品堆满了沙发。Cassie准备在闲鱼上慢慢出售。没想到这个会所竟然被查得这么严。 十年前，Cassie的名字叫王细娟。从乡下坐中巴车倒腾了四五个小时到达拱宸桥，落脚在一个自建房的隔间里。 白天，她去电子厂打工。骑着共享单车回自建房，飘来一张周围新房的售楼宣传单，塞纳花园。“单价2万，高层精装修临江洋房”。这个价格似乎一天打两份工还能接受。晚上做完饭店帮厨的兼职回来，她决定问一个本地的小姐妹。 “小美，你看这个单价，要不要凑一凑付个首付？” “两万？这价格也太离谱了，几年前我爸妈买的时候才五千一平呢，你等等降价吧！” “啊，那你名下的房子准备什么时候出售啊？” “暂时先看看吧，我还等着涨价呢。” 王细娟明白，这就是没上车和上车了的区别。她觉得听朋友的意见没什么用，听中介的忽悠又容易被骗。揣着兜里的小几万块钱，想想后续的房贷压力，以及还要定期给家里打钱，她决定再攒攒。 没想到，两年过去了，她还是没上车。一方面是因为房价跳涨得太快，中心城区一天一个概念，本准备买拱宸桥的新楼盘，一夜间每平就涨了4000；再看老破小，随着几个小区出了考上名校高中的尖子生，老破小也成了中产阶级高攀不上的学区房；往偏一点去看房，一出了新城概念，无人问津的楼盘也瞬间坐地起价。她打工攒的钱，从买一套小户型，迅速缩水成了一个厕所。 王细娟想，学历改变命运，应该去读个本科，出来找工作就容易了。于是她通过考试，考上了一个社科类本科，希望毕业后能找份体面工作。 四年毕业后，这个城市的房价已经翻了两倍。王细娟拿着简历四处找工作，但她发现，原本两个月工资能买一平郊区的房子，现在得攒半年才能买得起一平了。 她在招聘网站上海投了简历，但是找到的工作薪资差距都和她想象得非常大。一个月6000，她差不多不吃不喝70年能全款买下一套房子，从20岁干到90岁，步履蹒跚地用钥匙打开属于自己的那扇门。——不对，还没考虑通货膨胀和三胎任务，90岁的自己，得帮3个小孩带9个孙子孙女。 在格子间里干了一年后，王细娟的工作也没什么起色。她做的是宣传工作，公司效益不好，第一个裁的就是这些岗位。王细娟感到非常不解，那年拿到大学文凭的时候，都觉得前途一片光明，怎么一年后，就成了一个找不到工作的社畜呢？ 她路过一片工地，有一块木牌上写着：“招建筑数控工人，三个月培训上岗，5000包吃包住。”但是来应聘的人寥寥无几。她不仅感到奇怪，问了工头：“怎么这么高的工资还没招到人？” 工头耷下眼皮没瞅她：“5000哪能招到蓝领工人啊，5000只能招到大学生。” 王细娟回家，又投了一堆简历，让她去面试的岗位，都是一样的话术。转正后可大幅涨薪，意味着试用期可能是3000。弹性办公，意味着24小时待岗。单位有夜宵福利，意味着没有加班费。遭受过社会毒打的王细娟比来比去，最后找了份楼盘销售的工作。 每天都有中介带来的看房客，有的是攒了好几年积蓄准备结婚的小夫妻，有的是掏空六个口袋的大学生，有的是一次性买好几层楼的温州投资客。迎来送往一波波人，王细娟自己还是没能买得起最小的户型。 不过，当销售的提成非常惊人。楼盘需求旺盛的几个月，每套房的提成就有5000。到开盘的时候，王细娟她们就像打了鸡血，日夜守在售楼处不想放过一条鱼。 随着腰包渐渐变鼓，王细娟也有信心去看房了。她深知现在炒房最有利的是“红盘”：就是比周边二手房价格低，往往是拿地限价的楼盘。这样的楼盘一摇中，就相当于赚了几百万。每次红盘开盘，这座城市就会万人空巷，人人抢着拿房票去摇。 这天，她好不容易在银行打出了存款证明，加入了摇号大军，中介却遗憾地告诉她：30岁以下的单身群体暂时摇不到这个楼盘，优先照顾的是大龄无房家庭和人才。 这条消息一出，王细娟就和多数红盘无缘了。在她看房过程中，这座城市又因一场国际盛会拔高了Level，房价又一次推高了预期。王细娟失望地发现，她只能往更偏更远的小区去看了。 屋漏偏逢连夜雨，疫情袭来，人员密集的场所纷纷关门。王细娟在家呆了一年，每天上单位的网课培训，吃着外卖，领着一个月3000的底薪。躺在和六年前一样的隔断间里，回想起这些年噌噌噌涨的房价，一夜醒来涨好几万，又要多奋斗好几年，涨100万比挣100万容易多了，而她，从观望到绝望…… 一年后，随着疫情恢复，王细娟又开始了一轮海投。从销售到文职，再到事业单位，她都应聘了一遍。最后，她走进了夜色会所。 夜色会所堪称是有钱人扎堆。 她亲眼见过一名富翁为自己的小情人25岁的生日送了25份礼物，以弥补他们相见恨晚的情缘，礼物从奢侈品到现金应有尽有。王细娟虽然没有一夜暴富，但对比过去也算是咸鱼翻身了，劝老主顾开几瓶贵得离谱的洋酒，就能获得不少提成。在物质衡量一切的地方，一些违法乱纪的事便免不了了。 王细娟变成了Cassie，她平静地接受了自己的堕落。30岁生日这一天，她看着自己的余额，终于够本金摇江边的大平层了。这些年来，她深夜排队摇号，冒着疫情风险摇号，排队8小时摇号，都无一命中。中签率只有1%的钱塘壹号院，一共260套房子，光登记就超过了三万人。落地窗对着灯火辉煌的江，附近是这个城市最贵的奢华豪庭。她去寺庙里求了签，请佛祖一定要保佑她摇中这个楼盘。 生日晚会当天，她叫来各种老主顾，一起在包厢里为她庆生。会所包厢里布置了各种黑色和金色的气球，女宾们都穿着黑色丝绒裙，还叫来了摄影师，增加了仪式感。等到生日宴最高潮时，一群jc破门而入，“我们接到举报，你们这里有有偿不良交易！” 美女们开始尖叫，踩着高跟鞋试图趁乱逃走。大款们双手捂脸，希望jc不要拍到他们的正脸。最终，这些人被连夜带入了看守所。Cassie因涉嫌性交易罪名，被判处有期徒刑三年。 她慌慌张张地拿着自己的包，坐进了警车。突然，一条短信跳了出来： “恭喜您摇中钱塘壹号院。” ","date":"2021-06-30","objectID":"/untouchable-houses/:0:0","tags":null,"title":"[小说] 永远的红盘","uri":"/untouchable-houses/"},{"categories":["编程"],"content":"前言 如果问一个模拟器的作者为什么要编写模拟器，不同人的回答可能不尽相同。就比如你问一个 MineCraft 玩家为什么要在游戏里造一个 CPU，有的人会说，想给自己和大家展示 CPU 的工作原理；也有人会说，造一个 CPU 出来很酷不是吗；当然还有人会直接说，因为我能！ 一个现实的问题是，随着厂家停止生产过时的游戏机，这些古董终有一天也会只在博物馆里才能见到，而曾经在上面运行的游戏也会烟消云散。 也只有模拟器能让以后的人们能看到这些历史上的游戏是什么样子的。 相信很多人在初学编程后都对编写一个 GameBoy 或 NES 模拟器念念不忘。不管是在 Google 还是 Github 上都可以搜到大量的模拟器实现代码和博文。各种语言的都有，比如 C++、Go、Python、JavaScript 等等。 本人无意于重复造轮子。 GameBoy 作为最简单的游戏主机/掌机之一，麻雀虽小，却也五脏俱全。借由对 GameBoy 运行流程的分析，可一瞥早期游戏机乃至计算机的工作原理，也可以看到在硬件机能严重受限的条件下的游戏都是如何设计出来的。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:1:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"参考资料 no$gmb：完美而经典的 GameBoy 模拟器实现，可单步调试。 pandocs.txt：no$gmb 作者 Martin Korth 整理的文档。 GameBoy CPU Manual：任天堂官方公布的 GameBoy 文档。 GameBoy Opcode Summary：CPU 操作码总结。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:1:1","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"术语 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:2:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"机型缩写 缩写 全称 GB GameBoy GBP GameBoy Pocket GBC / CGB GameBoy Color SGB Super GameBoy ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:2:1","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"硬件 MBC - Memory Bank Controller ROM - Read Only Memory RAM = Random Access Memory OAM - Object Attribute Memory ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:2:2","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"寄存器 简称 全称 地址 LCDC LCD Control Register $FF40 STAT LCD Status Rigister $FF41 SCY Scroll Y $FF42 SCX Scroll X $FF43 LY LCD Y坐标 $FF44 LYC LY Compare $FF45 WY Window Y Position $FF4A WX Window X Position minus 7 $FF4B DMA Direct Memory Access $FF46 BGP Background Palette $FF47 OBP Object Palette $FF48 - FF49 IF Interrupt Flags $FF0F IE Interrupt Enable $FFFF ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:2:3","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"技术参数 指标 内容 CPU 8-bit (Similar to the Z80 processor) Clock Speed 4.194304MHz (4.295454MHz for SGB, max. 8.4MHz for CGB) Work RAM 8K Byte (32K Byte for CGB) Video RAM 8K Byte (16K Byte for CGB) Screen Size 2.6\" Resolution 160x144 (20x18 tiles) Max sprites Max 40 per screen, 10 per line Sprite sizes 8x8 or 8x16 Palettes 1x4 BG, 2x3 OBJ (for CGB: 8x4 BG, 8x3 OBJ) Colors 4 grayshades (32768 colors for CGB) Horiz Sync 9198 KHz (9420 KHz for SGB) Vert Sync 59.73 Hz (61.17 Hz for SGB) Sound 4 channels with stereo sound Power DC6V 0.7W (DC3V 0.7W for GB Pocket, DC3V 0.6W for CGB) ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:3:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"地址映射 GameBoy 地址线是 16 位，用于表示 ROM，RAM，I/O 寄存器寻址。 地址段 作用 0000-3FFF 16KB ROM Bank 00 (in cartridge, fixed at bank 00) 4000-7FFF 16KB ROM Bank 01..NN (in cartridge, switchable bank number) 8000-9FFF 8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode) A000-BFFF 8KB External RAM (in cartridge, switchable bank, if any) C000-CFFF 4KB Work RAM Bank 0 (WRAM) D000-DFFF 4KB Work RAM Bank 1 (WRAM) (switchable bank 1-7 in CGB Mode) E000-FDFF Same as C000-DDFF (ECHO) (typically not used) FE00-FE9F Sprite Attribute Table (OAM) FEA0-FEFF Not Usable FF00-FF7F I/O Ports FF80-FFFE High RAM (HRAM) FFFF Interrupt Enable Register 使用最多的是 ROM 和 RAM， ROM位于卡带上，分配给 ROM 的地址空间只有 16 KB + 16 KB， 但卡带的 ROM 可能超过 32 KB，比如 Super Mario Land 的 ROM 就有 64 KB，事实上，GameBoy支持最大 2 MB 的 ROM。 为了能访问到所有的 ROM 内容，我们将 ROM 划分成一个个 16 KB 的块，称为 bank。 00 号 bank 占有第一个 16 KB 地址空间（0000-3FFF）， 而第二个 16 KB 的空间（4000-7FFF）可以根据需要映射至不同的 bank，这个映射由 MBC（Memory Bank Controller 控制）。 可想而知，00 号 bank 应该被用来存通用的游戏内容，比如角色相关、控制相关的代码。其他 bank 存的内容则是会随着游戏进行而动态加载和卸载的，比如关卡相关的数据。 E000-FDFF 为 C000-DDFF 的镜像地址，读写前者的效果与读写后者的效果完全一样。 第一个 ROM Bank 中的跳转向量 约定俗成的重要函数入口一般写在下面的地址里： 对于 RST 指令：0000, 0008, 0010, 0018, 0020, 0028, 0030, 0038 对于中断处理：0040, 0048, 0050, 0058, 0060 当然，如果程序中没有使用 RST 或某些中断就可以不管，拿这些地址用作别的用途。 卡带头 0100-014F 中为卡带头数据，内容包括程序信息、入口、校验和、MBC芯片信息、ROM 和 RAM 大小，等等。 外部硬件 A000-BFFF 可用于外接内存的寻址，比如，存储游戏状态、高分表，等等，它需要电池额外供电。 外接内存也是在卡带上，可能很大，类似的也要分成一个个 8 KB 的 bank，由 MBC 控制当前将哪个外部 RAM 的 bank 映射到 A000-BFFF。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:4:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"MBC 类型 MBC (Memory Bank Controllers) 位于卡带上，而不是 GB 游戏机上。MBC 有多种类型，卡带头的数据里带有 MBC 类型（位于 0147）。包含下面几类： None (32KByte ROM only) MBC1 (max 2MByte ROM and/or 32KByte RAM) MBC2 (max 256KByte ROM and 512x4 bits RAM) MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) HuC1 (MBC with Infrared Controller) ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:5:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"None 仅使用 32 KB ROM，占用 0000-7FFF 地址空间；可能带有最多 8 KB 的额外 RAM，占用 A000-BFFF。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:5:1","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"MBC1 这是 GB 使用的最初代 MBC 芯片。MBC1 有两种模式，一种支持最大 2M Byte ROM 和 8K Byte RAM，另一种支持最大 512K Byte ROM 和 32K Byte RAM。前者称为 ROM banking 模式，后者称为 RAM banking 模式。 0000-3FFF：ROM Bank 00，总是包含卡带开头的 16 KB 数据。 4000-7FFF：ROM Bank 01-7F。2MB 的 ROM 可以被分成 128 个 bank，这样 ROM bank的编号从 00 到 7F 就足够了。但是 20，40，60 这 3 个编号的 bank 其实读不到，所以实际可用的总 bank 数只有 125 个。 A000-BFFF：RAM Bank 00-03，如果有的话。不同卡带上附带的 RAM 可能有 2K Byte（占用 A000-A7FF）、8K Byte（占用A000-BFFF）或者 32K Byte（4个 8 KB 的 bank）。 一般来说，0000-7FFF 的地址空间是 ROM，它是只读的。往这上面写数据并不会改变 ROM 的内容。 GB 把往这个地址段上的写指令处理为向 MBC 寄存器写数据。往不同地址段的写会有不同的含义。 0000-1FFF： RAM Enable，一般来说，往这个地址段写 00h 表示关闭外部 RAM，写 0Ah 表示打开。但其实只要写任何低四位是 0Ah 的数都是打开外部 RAM，其他则是关闭。只有打开了外部 RAM，这部分内存才能在运行中被读写。（Super Smart Card 不需要指令打开，它总是开的） 2000-3FFF： Lower 5 Bits of ROM Bank Number。取写入值的最低5位。如果是选择 2MB ROM / 8KB RAM 模式，则刚好可以表示 32 个 ROM bank 编号（00-1F）。特别的，如果写的是00，GB会认为写的是 01。 4000-5FFF： Upper 2 Bits of ROM Bank Number。取写入值的最高2位。如果选用了 512KB ROM / 32KB RAM 模式，则这个值用来表示 RAM bank 编号。如果选用了 2MB ROM / 8KB RAM 模式，则这2个bits用作 ROM bank 编号的最高两位。 但由于编号最低 5 bits 若是 00 则一定会视为 01，对 20、40、60 的访问变成了 21、41、61。所以这 3 个 bank 其实是不可能被读到。 6000-7FFF：ROM/RAM 模式切换。最低位写 0 表示 ROM Banking 模式，这是开机后的默认模式。最低为 1 表示 RAM Banking 模式。这两个模式之间可以自由切换。也就是一个卡带可以既有 2MB ROM，又有 32 KB 外部 RAM。只不过在 RAM banking 模式下，只有 00-1Fh 号的 ROM bank 可用，在 ROM banking模式下，只有 00 号的 RAM bank 能用。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:5:2","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"MBC2 MBC2支持最大 256 KB ROM 和 512x4 bits RAM，它和 MBC1 很多地方是一样的。下面列出不同的部分。 读 4000-7FFF：对应 ROM Bank 01-0F，只有 16 个bank 可用。 A000-A1FF：对应 256 Byte RAM。因为这部分 RAM 是由 512 个 4 bit组成的，所以每个地址只有最低4位有效。这也是为什么256 Byte RAM 会占用 512 的地址空间。 写 0000-1FFF：RAM Enable，不是所有的地址都有效。The least significant bit of the upper address byte must be zero to enable/disable cart RAM. 有点绕，就是说当写的地址的较高位byte的最低位是0，才能开关 RAM 读写，例如这些地址段：0000-00FF, 0200-02FF, 0400-04FF, …, 1E00-1EFF. 其他往地址段写不会起任何作用。推荐使用 0000-00FF 地址段。 2000-3FFF：ROM Bank Number。(XXXXBBBB - X = Don’t cares, B = bank select bits)。设置 ROM bank 编号。不是所有的地址都有效。The least significant bit of the upper address byte must be one to select a ROM bank. 当写的地址的较高位byte的最低位是1才能设置成功，比如 2100-21FF, 2300-23FF, 2500-25FF, …, 3F00-3FFF. 推荐用 2100-21FF 地址段。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:5:3","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"MBC3 MBC3 在 MBC1基础上多了一个时钟 Real Time Clock (RTC)。下面列出与 MBC1 不同的部分。 读 4000-7FFF 时，20、40、60号 ROM bank 可以正确被读到。 A000-BFFF 既可以被用作 RAM bank 00-03 的地址，也可以用来读写 RTC 的4个寄存器。 0000-1FFF 跟 MBC1 功能一样，再额外加上可以开关 RTC 寄存器读写。通过写 0Ah / 00h 来开和关。 2000-3FFF ROM bank number。写入值的低7位表示 ROM bank 编号。00依然被当作01。 4000-5FFF RAM Bank Number / RTC Register Select。若写入值是 00-03，则 A000-BFFF 地址段被映射成外部 RAM 相应的 bank；若写入值是 08h-0Ch，则读写 A000-BFFF 相当于读写 RTC 寄存器（通常用地址 A000 读写）。详见下表。 6000-7FFF Latch Clock Data。往这个地址先写 00h，再写一个 01h，可以开关时间锁。锁关上的期间下， RTC中读到的值不会变化。直到锁打开。因为要读出完整的时间需要很多指令，读时间的过程中这些寄存器很容易改变值，因此需要锁住。锁住的时候后台的时间仍然在跑，只不过读出来的是锁住时的时间。解锁之后会变成正常的时间。 RTC 寄存器 当 4000-5FFF 写入 08h-0Ch 各个值时，读写 A000-BFFF 等价于读写 RTC 寄存器，具体为 写入值 寄存器 含义 说明 08h RTC S Seconds 0-59 (0-3Bh) 09h RTC M Minutes 0-59 (0-3Bh) 0Ah RTC H Hours 0-23 (0-17h) 0Bh RTC DL Days Lower 8 bits of Day Counter (0-FFh) 0Ch RTC DH 见下面 RTC DH.0 Days Bit 8 RTC DH.6 Halt 0=Active, 1=Stop Timer，默认状态是 1 RTC DH.7 Day Counter Carry Bit 1=Counter Overflow The Day Counter 用来表示天数的寄存器有 9 bit，可以表示 0-511 天，然后 RTC DH.7 就会记录到溢出，除非在 runtime 清掉溢出位。一种做法是每次进游戏都把天数读出来，存到外部 RAM 里，作为 offset；RTC里的天数清零。这样，只要每 511 天进一次游戏，就能保证时间正确。 访问 RTC 的频率 推荐相邻两次访问 RTC 寄存器的时间间隔不低于 4 毫秒。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:5:4","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"HuC1 跟 MBC1 一样，只不过带有红外 LED 输入输出设备。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:5:5","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"Gamegenie/Shark Cheats Game Shark 和 Gamegenie 类似转接头，用于作弊或打补丁。 Gamegenie 是 ROM 补丁，做法是先记录要打补丁的 ROM 地址和新旧数据，如果一个 read 指令地址对上了，读到 ROM 上的数据也跟记录的旧数据一样，那么就将记录里的新数据传给 GB。 Game Shark 是 RAM 补丁，猜测是在 VBlank 的时候扫 RAM，修改值。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:5:6","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"手柄输入 手柄共有 8 个按键：上、下、左、右、A、B、Start、Select。 通过读写 FF00h 获得手柄状态。该地址的 bit 0-5 有效，bit 0-3 只读，一次性返回 4 个按键的状态；bit 4-5 只写，如果仅有 bit 4 被激活，那么返回上下左右的状态。 bit 4 bit 5 bit 0 right A bit 1 left B bit 2 up select bit 3 down start 注意：这里的激活指的是设置低电平（0），返回的状态也是 0 表示按下，1 表示没按。返回的 Byte 只有最低 4 位有效。因此需要读两次才能获得全部按键状态。 下面是一个读取手柄状态的样例。 Game: Ms. Pacman Address: $3b1 LD A, $20 ; bit 5 = $20 LD ($FF00), A ; select P14 by setting it low LD A, ($FF00) LD A, ($FF00) ; wait a few cycles CPL ; complement A AND $0F ; get only first 4 bits SWAP A ; swap it LD B, A ; store A in B LD A, $10 LD ($FF00), A ; select P15 by setting it ow LD A, ($FF00) LD A, ($FF00) LD A, ($FF00) LD A, ($FF00) LD A, ($FF00) LD A, ($FF00) ; Wait a few MORE cycles CPL ; complement (invert) AND $0F ; get first 4 bits OR B ; put A and B together LD B, A ; store A in B LD A, ($FF8B) ; read old joy data from ram XOR B ; toggle w/ current button bit AND B ; get current button bit back LD ($FF8C), A ; save in new Joydata storage LD A, B ; put original value in A LD ($FF8B), A ; store it as old joy data LD A, $30 ; deselect P14 and P15 LD ($FF00), A ; RESET Joypad RET ; Return from Subroutine ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:6:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"中断 同 PC 的体系结构一样，GB 的 CPU 在执行完一条指令后也会检查是否有中断触发，如果有则会跳转至中断处理程序的入口。 GB 共有 5 种中断类型，分别是： 类型 优先级 说明 地址 V-Blank 1 V-Blank 周期 0x0040 LCDC status 2 LYC == LY 的时候 0x0048 Timer Overflow 3 TMA 溢出 0x0050 Serial Transfer 4 串口传输结束 0x0058 Hi-Lo of P10-P13 5 手柄输入 0x0060 寄存器 IF 记录当前有哪些中断被触发，IE 记录有哪些中断允许执行。 此外，还有一个 IME flag 作为所有中断的总开关。IME 无法通过写内存的方式改变值，只能通过 EI 和 DI 指令开关。 当中断产生时，IF 的相应 bit 会被设为 1，如果 IME 和 IE 对应的 bit 都是 1，则会执行下面 3 个步骤： IME 被设为 0，以避免中断的嵌套； PC 压栈； 跳转到对应的中断处理函数起始地址。 当然，也可以在中断处理程序里通过 CPU 指令打开 IME，就允许了中断的嵌套。中断返回可以用 RET 或 RETI 指令，区别在于 RETI 会打开 IME，而 RET 不会。 RETI 相当于 EI + RET 两个指令。 如果同时有多个中断被触发，则会按照优先级顺序依次处理，V-Blank优先级最高，手柄输入最低。 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:7:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"显示 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:8:0","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"一些概念 Background GB 的背景（background，或者称为screen buffer） 包含 256x256 像素（32x32个tile，每个tile占8x8），其中的 160x144 的像素会被显示出来，SCX和SCY记录了屏幕左上角在背景上的坐标。背景的边界类似于OpenGL纹理的 wrap 采样模式。 显存的其中一块区域用来存 background 的 32x32 个tile的id（每个id是1一个Byte），称为 Background Tile Map，位于 9800h-9BFFh 或 9C00h-9FFFh，共 1024 Byte，取决于 LCDC 的设置。tile的具体内容存在 Tile Data Table中，对应地址为 8000h-8FFFh 或者 8800h-97FFh，占用 4096 Byte，存了 256 个 Tile，每个 Tile 占 16 Byte，可通过 LCDC 寄存器的设置选择在哪一段内。对于第一种情况，tile id被当作无符号数，从0到255，比如0号tile在地址8000；第二种情况，tile id 是有符号数，从-128到127，0号tile在地址9000。 在 CGB 模式下，有一个额外的 32x32 的 Byte 存在 VRAM bank 1，存了每个 background tile map 额外的信息。 Bit 0-2 Background Palette number (BGP0-7) Bit 3 Tile VRAM Bank number (0=Bank 0, 1=Bank 1) Bit 4 Not used Bit 5 Horizontal Flip (0=Normal, 1=Mirror horizontally) Bit 6 Vertical Flip (0=Normal, 1=Mirror vertically) Bit 7 BG-to-OAM Priority (0=Use OAM priority bit, 1=BG Priority) 如果这里的 bit 7 设为 1，那么对应的 background tile 的优先级比所有的 sprite 都高，不管 sprite 的 OAM 设了怎样的优先级。但还有一个优先级的总开关在 LCDC 的 bit 0，可以屏蔽 background tile的优先级。 Window 背景以外，还有窗口（window）的概念。窗口覆盖在背景之上，不可滚动（即窗口大小不超过一屏幕）。窗口的左上角在屏幕上的位置由WX和WY寄存器指定。用于画 window 的 tile 也存在 Tile Data Table 里。 If the window is used and a scan line interrupt disables it (either by writing to LCDC or by setting WX \u003e 166) and a scan line interrupt a little later on enables it then the window will resume appearing on the screen at the exact position of the window where it left off earlier. This way, even if there are only 16 lines of useful graphics in the window, you could display the first 8 lines at the top of the screen and the next 8 lines at the bottom if you wanted to do so. WX may be changed during a scan line interrupt (to either cause a graphic distortion effect or to disable the window ( WX\u003e166) ) but changes to WY are not dynamic and won’t be noticed until the next screen redraw. Tile Tile Data Table中存了一个个 8x8 的tile，每个像素占2 bit，所以一个 tile 占 16 Byte。 这16个byte每两个分成一组，编码一行的8个像素。Byte 0-1 表示第一行，Byte 2-3 表示第二行，等等。一组的两个byte中，第一个表示每个像素的低位（least significant bits），第二个表示每个像素的高位（upper bits）。每个 Byte 中，bit 7 表示最左侧像素，bit 0 表示最右侧像素。 如下面的例子，是一个8x8的像素的 tile： . 3 3 3 3 3 . . 2 2 . . . 2 2 . 1 1 . . . 1 1 . 2 2 2 2 2 2 2 . 3 3 . . . 3 3 . 2 2 . . . 2 2 . 1 1 . . . 1 1 . . . . . . . . . 编码过程如下： . 3 3 3 3 3 . . -\u003e 01111100 -\u003e 7C 01111100 -\u003e 7C 2 2 . . . 2 2 . -\u003e 00000000 -\u003e 00 11000110 -\u003e C6 1 1 . . . 1 1 . -\u003e 11000110 -\u003e C6 00000000 -\u003e 00 2 2 2 2 2 2 2 . -\u003e 00000000 -\u003e 00 11111110 -\u003e FE 3 3 . . . 3 3 . -\u003e 11000110 -\u003e C6 11000110 -\u003e C6 2 2 . . . 2 2 . -\u003e 00000000 -\u003e 00 11000110 -\u003e C6 1 1 . . . 1 1 . -\u003e 11000110 -\u003e C6 00000000 -\u003e 00 . . . . . . . . -\u003e 00000000 -\u003e 00 00000000 -\u003e 00 于是，这个 tile 在 ROM 中存的数据（从低地址到高地址）就是 7C 7C 00 C6 C6 00 00 FE C6 C6 00 C6 C6 00 00 00 。 每个像素存的 0-3 的值会经过 palettes 转化成真正的颜色（或灰度）。调色板对应的寄存器位于 FF47-FF49 (Non CGB Mode) 或者 FF68-FF6B (CGB Mode)。 Sprite sprite表示前景，一般是角色、怪物等可移动的物体。GB 可以显示最多 40 个 sprite，每行可最多显示 10 个。sprite 大小可以是 8x8 或 8x16。Sprite 的图像和 tile 类似，只是 sprite 只在 8000-8FFF（共 4096 Byte）。 每个要画的 sprite id (0-255) 存在 OAM 中。OAM 地址范围是 FE00-FE9F，被分成 40 个 4 Byte 的块，每块存 id 用 一个 Byte，存位置用 2 个 Byte，剩下的 Byte 存一些其他属性。每个 Byte 含义如下： Byte 0：sprite 左上角在屏幕的 y 坐标 Byte 1：sprite 左上角在屏幕的 x 坐标 Byte 2：tile id（0-255），如果 sprite 是 8x16，最低位会被视为 0。 Byte 3：一些flag。具体如下： 3_7：优先级。如果设为 0，sprite 会画在 background 和 window 之上；如果设为 1，则 sprite 会被颜色为 1-3 的 background 或 window 遮挡。如果 background 或 window 的颜色是 0，则无论哪种情况都是 sprite 在上面。 3_6：y flip，如果被设为 1，则按 y 轴镜像 3_5：x flip，如果被设为 1，则按 x 轴镜像 3_4：palette number。调色板有两个可以选，如果设为 0 则选用 OBJ0PAL，设为 1 则选用 OBJ1PAL。仅在非 CGB 模式下有效。 3_3：Tile VRAM-Bank。仅在 CGB 模式下有效。 3_2-0：Palette number，仅在 CGB 模式下有效，表示调色板编号（0-7） sprite 只有 3 种颜色，颜色 0 表示透明。 若 sprite 是 8x16 模式，则一个 sprite 占用了两个 tile，此时 tile id 的最低位不生效。 如果有相同坐标的 sprite 在屏幕上有重叠，则 x 较小的有较高优先级，在上面；如果 x 一样，则根据 OAM 的地址（而不是 sprite id）的高低确定优先级，地址越小优先级越高，比如 FE00 拥有最高优先级，FE04 其次，在最上面。 CGB 模式下，重叠的 sprite 不比较 x 坐标，直接根据 OAM 地址确定优先级。 位于 x=0, y=0 的 sprite 其实不会在屏幕上显示出来，需要将 x 减去 8，且 y 减去 16，才是 sprite 左上角在屏幕上的坐标。因此，要把 sprite 画在左上角，需要设置 x = 8，y = 16。 每一行最多只能画 10 个 sprite，如果超过这个限制，低优先级的不会被画出来。如果想要不用的","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:8:1","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["编程"],"content":"显示相关的寄存器 LCD Control Register LCD Control Register 在地址 FF40，可读写，每个 bit 含义如下： Bit 7 - LCD Display Enable (0=Off, 1=On) Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF) Bit 5 - Window Display Enable (0=Off, 1=On) Bit 4 - BG \u0026 Window Tile Data Select (0=8800-97FF, 1=8000-8FFF) Bit 3 - BG Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF) Bit 2 - OBJ (Sprite) Size (0=8x8, 1=8x16) Bit 1 - OBJ (Sprite) Display Enable (0=Off, 1=On) Bit 0 - BG Display (for CGB see below) (0=Off, 1=On) 注意事项: Bit 7 从1置为0只能在 V-Blank 期间做，否则将损坏硬件。确认是否在 V-Blank 只要读 LY 的值（位于 FF44），当 LY \u003e= 144 时就是 V-Blank。当 LCD 关闭时，VRAM 和 OAM 可以任意访问。 Bit 0：对于 SGB 和 GB，bit 0置为0表示不画背景（显示白色），但窗口和 sprite 仍然可以画，取决于 bit 1 和 bit 5 的设置；对于 CGB 模式下的 CGB，bit 0置为0表示背景和窗口的优先级被忽略，sprite永远在背景和窗口之上，而不管 OAM 和 BG Map 中的优先级 flag；对于非 CGB 模式下的 CGB，bit 0置为0表示不画背景和窗口，不管 bit 5 设置多少。 LCD Status Register LCD Status Register 在地址 FF41，可读，部分bit可写 Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) Bit 5 - Mode 2 OAM Interrupt (1=Enable) (Read/Write) Bit 4 - Mode 1 V-Blank Interrupt (1=Enable) (Read/Write) Bit 3 - Mode 0 H-Blank Interrupt (1=Enable) (Read/Write) Bit 2 - Coincidence Flag (0:LYC\u003c\u003eLY, 1:LYC=LY) (Read Only) Bit 1-0 - Mode Flag (Mode 0-3, see below) (Read Only) Bit 1-0 组合对应的状态如下： 0: During H-Blank，此时 CPU 可访问 VRAM（8000h-9FFFh）和 OAM（FE00h-FE9Fh） 1: During V-Blank(or the display is disabled)，同样的，此时 CPU 可访问 VRAM（8000h-9FFFh）和 OAM（FE00h-FE9Fh） 2: During Searching OAM-RAM，LCD控制器在读OAM，此时 CPU 不能访问 OAM 3: During Transfering Data to LCD Driver。此时 OAM 和 VRAM 都不能被 CPU 访问。如果是 CGB 模式，则 Palette Data (FF69,FF6B) 也不能被访问。 上述 4 种状态典型的时序图如下： 2330002330002330002330002330002331111111111111123000 023三个状态轮换的周期大约是 109 微秒，0占48.6微秒，2占19微秒，3占41微秒。023每隔16.6毫秒会被状态1打断（V-Blank），状态1每次持续1.08毫秒。 以时钟周期记，状态0每次持续 201-207 周期，状态2每次持续 77-83 周期，状态3持续 169-175 周期。023的循环需要 456 周期，在此期间扫描线画完一行；状态1持续 4560 周期，扫描线在第 144 到 153 行。每隔 70224 周期屏幕刷新一次，对应的帧率大约是 60 fps。 LCD Position and Scrolling SCY(FF42) / SCX(FF43): 如前所述，表示 background 在屏幕的偏移。 LY(FF44) 是只读的，表示当前往 LCD 传输的数据到哪一行了。取值范围是0-153，若值是 144 到 153 之间表示出于 V-Blank。Writing will reset the counter. （意思是往 LY 写任何数都会重置 LY 为 0？） LYC(FF45) 用于跟 LY 比较，产生中断。见下文。 WY(FF4A) / WX(FF4B)：window 的左上角在屏幕上的偏移。注意 WX 是 window 的 x 轴偏移减去 7。 需要注意的是，WY/WX 是 window相对于屏幕的偏移，而 SCY/SCX 是屏幕相对于 256x256 的 background 的偏移。 LCD Interrupts LCD相关的中断有两个： INT 40，V-Blank中断，发生于 V-Blank 开始时 INT 48，LCDC Status Interrupt，发生于 LY 和 LYC 相等的时候。一旦相等，STAT寄存器的 coincident bit 被设为1，并且产生一次中断 ","date":"2021-05-18","objectID":"/gameboy-simulator-dev-log/:8:2","tags":null,"title":"GameBoy 模拟器开发记录","uri":"/gameboy-simulator-dev-log/"},{"categories":["图形"],"content":"本文翻译自 Eric Arnebäck 的一条 推文，作者提出了图形程序员进阶的一些中肯的建议。我觉得其中有不少值得借鉴的点。 如果你已经可以无碍地听懂 GDC 和 siggraph 的最新的报告和论文，并且可以用相对合理的时间实现出来，那么你已经是很资深的图形程序员了，会有大量游戏公司向你抛来橄榄枝。那么我是如何做到的呢？ 我建议每个新手图形程序员都实现一个自己的 mini 渲染引擎，包括以下功能： 粒子系统 水和动态反射 环境光遮蔽 延迟渲染 视锥体裁剪 阴影渲染 抗锯齿 等等。实现一个功能齐全的渲染引擎，是从新手到熟手的最好途径。 每当实现完一个高级的功能，一定要写一篇博客详细介绍。既可以让你更深入地思考自己所实现的东西，也可以提升技术交流的水平，这对于工业界是非常重要的能力。将博客分享给其他人，同行的讨论能给你更多启发。 对业界的动态保持关注，每周都读一下最新的 paper，和大佬发的最新博客及推文。 如果没时间从头到尾地读论文，可以跳过某些部分，直到自己能掌握论文背后的主旨。论文里往往包含大量细节内容，这些只在你真的坐下来亲自去实现它的时候有用。于我而言，了解主旨基本就足够了。 以后在项目中引入一个论文的工作，只要掌握它的大体思路。 我认为资深图形程序员的一个主要的特点就是可以用相对合理的时间量实现最新的 siggraph / EG 等会议的论文。关于如何实现论文，又有几点看法。 首先从头到尾读几遍论文，重点关注“方法”部分。从这部分提炼出“最简可行的原型”，也就是抛去各种优化，先不关注性能，而是思考如何用最简单的方式实现它。有了实现方案以后接着思考：将它用自己的引擎实现出来有多困难？它的效果能否达到我想要的水准？ 考虑好之后就可以琢磨如何优化和实现论文的高级部分。 实现论文一个重要的点是要有能比较的 ground truth。比如实现一个实时间接光算法，你需要同时实现一个 path tracer（基于 Mistuba 或 embree）。又比如实现一个 shadow map 的 filter 算法，肯定也要跟 PCF 进行比较。 对于一些非常篇数学和抽象的论文，很难立马想到如何将它翻译成代码，以下是一些建议： 多数情况下，计算积分就是求和 集合的记号用数组来实现 经常会遇到的最小化的问题，可以通过找梯度为 0 的点来解 求解偏微分方程（PDE）可以转化成有限差分（finite difference） 遇到大矩阵不要怕，它们一般都是用来表示许多小的简单的等式的联立 永远不要试图自己实现线性系统求解器，而是用 Eigen 库 简化问题，比如想象输入的 mesh 只有一个或几个三角形，代入公式中看看会变成什么样，这有助于加深理解 考虑三维情况之前，先考虑二维甚至一维下的情况 更多建议： 阅读参考文献中的论文，它们可能对一些概念有更容易理解的解释 很多人会在硕士论文中实现 siggraph 论文，里面有大量宝贵的实现细节，可供参考 有些论文其实本身就写的很晦涩，可以给作者发邮件问清楚 可以询问同事，或者在 twitter 上问专家 下面是一些优化论文实现的建议： 学会使用性能分析工具，比如 NVidia Nsight，可以快速定位代码中的 hotspot 读 这篇文章 使用版本控制工具，这样可以知道哪些修改会影响性能 最近读到安柏霖先生的博文，里面提到了各种职级的程序员应该具备的水平，比如 T8 - T9 级别（工作2-3年，正常晋升）应该可以轻松落地单点技术（比如战神的风场），T10 - T11 级别要能负责系统级别技术（没举例子，大概是地形系统、粒子系统、动画系统等吧）。 离题一句，安柏霖在这里主要是讨论“隐性知识”的重要性。这是书上和论文中不讲，但对于游戏开发至关重要的东西，非常琐碎。比如工具链、兼容性。相比之下，“显性知识”，也就是出现在各种高大上论文里的核心技术，其实是难度最小的部分，属于冰山浮在水面的那一块。更多的时间其实是要花在解决冰山的水下部分。 再多一些题外话。关于冰山的比喻还可以进一步推广，在整个游戏开发周期中，游戏画质、性能这些高精尖的硬性指标固然需要投入大量的程序、美术、TA的时间，但这些仍然只是冰山看得见的部分。隐藏在冰山下的是游戏节奏、手感、叙事等方面的打磨，因为难以量化，所以几乎很难有指导方向。 下面是 Eric Arnebäck 推特原文： How To become an advanced graphics programmer: Some general advice and tips from me, an expert graphics programmer huge thread below. If you are at the level at which you can comfortably read e.g. advanced GDC presentations and siggraph papers, and then implement them by youself in an reasonable amount of time, I consider you an advanced graphics programmer, and plenty of game companies would probably be interested in your skills. How can we acquire this level of skill? I shall tell you how I did it! Something that I think all beginning graphics programmers should do, is implement their own little rendering engine. I did this when I was a beginner, and implemented things like: rendering of particle systems water rendering, with dynamic reflections ambient occlusion' deferred rendering view frustum culling shadow rendering anti aliasing. and so on and so forth. working on a rendering engine and implementing all kinds of rendering features, is IMO the best way to go from beginner to intermediate. Whenever you implement something suffienctly advanced, make sure to write a blog post about it. Writing blog posts allows you to deepen your understanding of what you’ve implemented, and improves your communication skills, which is very important in this industry. and also, sharing your blog posts with people, often results in interesting discussions with other graphics programmer, and this deepens your understanding even more. Make an active effort to keep up with the latest developements in the field. Every week, read the latest blog posts, and latest papers that people post on twitter. Note that there is not always time to read all the new papers from beginning to end. in this situation, I think it is enough to skim the paper, and skim until you understand the main idea behind the paper. Papers can contain lots of nitty gritty details, but I think these are only necessary to understand, if you are really gonna sit down and implement the paper yourself. But if you’re pressed for time, understanding the main idea is more than enough in my opinion. If you have the main idea of the paper understood, then that is enough when you want to incorporate the","date":"2021-05-13","objectID":"/how-to-become-an-advanced-graphics-programmer/:0:0","tags":["经验"],"title":"How to Become an Advanced Graphics Programmer","uri":"/how-to-become-an-advanced-graphics-programmer/"},{"categories":null,"content":"关于我 一名 90 后 / 计算机专业毕业生 / 程序员 / 终身学习者 / 玩家。 \r","date":"2020-04-11","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于本站 此网站记录了我本人的想法、见闻，不定期更新，也不代表其他任何个人或组织的观点。 \r","date":"2020-04-11","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"联系方式 您可以通过下面的方式找到我: \r\r\r\r\r\r\r","date":"2020-04-11","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"}]